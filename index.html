<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <title>Visualizador 3D com UV</title>
  <style>
    body { margin: 0; display: flex; flex-direction: row; font-family: sans-serif; }
    #viewer { width: 50vw; height: 100vh; background: #111; }
    #controls { width: 50vw; padding: 10px; box-sizing: border-box; background: #222; color: #fff; }
    #uvCanvas { width: 100%; height: 50%; border: 1px solid #555; background: #000; display: block; margin-top: 10px; }
    button { padding: 8px 12px; margin-top: 10px; cursor: pointer; }
  </style>
</head>
<body>

<div id="viewer"></div>

<div id="controls">
  <h2>Controle do Modelo</h2>
  <div id="modelButtons"></div>
  <canvas id="uvCanvas"></canvas>
</div>

<script type="module">
import * as THREE from './libs/three.min.js';
import { GLTFLoader } from './libs/GLTFLoader.js';
import { GLTFExporter } from './libs/GLTFExporter.js';
import { XAtlasAPI } from './libs/xatlas.min.js';

let api, scene, camera, renderer, light, mesh;

async function init() {
  api = await XAtlasAPI({ locateFile: (file) => `./libs/${file}` });

  // Cena
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.z = 2;

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth / 2, window.innerHeight);
  document.getElementById('viewer').appendChild(renderer.domElement);

  light = new THREE.DirectionalLight(0xffffff, 1);
  light.position.set(1, 1, 2);
  scene.add(light);

  window.addEventListener('resize', onWindowResize);

  // Lista de modelos na pasta 'models/' (adicione mais aqui)
  const modelos = [
    'remontado_.glb'
  ];

  const buttonsContainer = document.getElementById('modelButtons');

  modelos.forEach(nome => {
    const btn = document.createElement('button');
    btn.textContent = `Carregar ${nome}`;
    btn.addEventListener('click', () => carregarModelo(`./models/${nome}`));
    buttonsContainer.appendChild(btn);
  });

  animate();
}

async function carregarModelo(caminho) {
  const loader = new GLTFLoader();

  if (mesh) scene.remove(mesh);

  loader.load(caminho, async (gltf) => {
      mesh = gltf.scene;
      scene.add(mesh);
      await gerarUV(mesh);
  }, undefined, (err) => {
      console.error(err);
      alert('Erro ao carregar o modelo: ' + caminho);
  });
}

function onWindowResize() {
  camera.aspect = (window.innerWidth / 2) / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth / 2, window.innerHeight);

  const uvCanvas = document.getElementById('uvCanvas');
  uvCanvas.width = uvCanvas.clientWidth;
  uvCanvas.height = uvCanvas.clientHeight;

  if (mesh) drawUV(mesh);
}

async function gerarUV(object3D) {
  const geometries = [];

  object3D.traverse(child => {
    if (child.isMesh && child.geometry) geometries.push(child.geometry);
  });

  if (!geometries.length) return alert('Nenhuma geometria encontrada.');

  for (const geom of geometries) {
    const positions = geom.attributes.position.array;
    const indices = geom.index ? geom.index.array : null;

    const atlas = api.createAtlas();
    atlas.addMesh(positions, indices);
    atlas.generate();

    const uvs = atlas.getUVs();
    geom.setAttribute('uv', new THREE.BufferAttribute(new Float32Array(uvs), 2));
    geom.attributes.uv.needsUpdate = true;
  }

  drawUV(object3D);
}

function drawUV(object3D) {
  const uvCanvas = document.getElementById('uvCanvas');
  const ctx = uvCanvas.getContext('2d');
  ctx.clearRect(0, 0, uvCanvas.width, uvCanvas.height);
  ctx.strokeStyle = '#0f0';
  ctx.lineWidth = 1;

  object3D.traverse(child => {
    if (!child.isMesh || !child.geometry.attributes.uv) return;

    const uvAttr = child.geometry.attributes.uv;
    for (let i = 0; i < uvAttr.count; i += 3) {
      const u0 = uvAttr.getX(i) * uvCanvas.width;
      const v0 = uvAttr.getY(i) * uvCanvas.height;
      const u1 = uvAttr.getX(i + 1) * uvCanvas.width;
      const v1 = uvAttr.getY(i + 1) * uvCanvas.height;
      const u2 = uvAttr.getX(i + 2) * uvCanvas.width;
      const v2 = uvAttr.getY(i + 2) * uvCanvas.height;

      ctx.beginPath();
      ctx.moveTo(u0, uvCanvas.height - v0);
      ctx.lineTo(u1, uvCanvas.height - v1);
      ctx.lineTo(u2, uvCanvas.height - v2);
      ctx.closePath();
      ctx.stroke();
    }
  });
}

// BotÃ£o para exportar modelo atual
const exportBtn = document.createElement('button');
exportBtn.textContent = 'Exportar Modelo (GLB)';
exportBtn.addEventListener('click', () => {
  if (!mesh) return alert('Nenhum modelo carregado.');

  const exporter = new GLTFExporter();
  exporter.parse(mesh, result => {
    let output;
    if (result instanceof ArrayBuffer) {
      output = result;
    } else {
      output = JSON.stringify(result, null, 2);
    }

    const blob = new Blob([output], { type: 'application/octet-stream' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = 'model.gltf';
    link.click();
  }, { binary: true });
});

document.getElementById('controls').appendChild(exportBtn);

function animate() {
  requestAnimationFrame(animate);
  if (mesh) mesh.rotation.y += 0.01;
  renderer.render(scene, camera);
}

init();
</script>

</body>
</html>